'use strict';

const RuCaptchaError = require('./RuCaptchaError');
const request = require('request');
const querystring = require('querystring');
const Image = require('image-binary');
const sleep = require('system-sleep');

class RuCaptchaClient {
	/**
	 * @param {String} apiKey - ключ API
	 * @throws {Error}
	 */
	constructor(apiKey) {
		if (apiKey.length !== 32) throw new RuCaptchaError('ERROR_WRONG_USER_KEY');
		this.apiKey = apiKey;
	}

	static create(apiKey) {
		return new RuCaptchaClient(apiKey);
	}

	/**
	 * Решает капчу
	 * @param {Object} [options={}]
	 * @return {Promise<{captchaId, text}>|Promise<void>}
	 * @throws {Error}
	 */
	async solve(options = {}) {
		if ('image' in options) this.image = options.image;
		if ('pingback' in options) {
			return await this._sendCaptcha(options);
		}

		let id = await this._sendCaptcha(options);
		let answer = null;
		do {
			sleep(5000);
			try {
				answer = await this._getAnswer(id);
			} catch (e) {
				if (e.id === 16 || e.id === 17) throw Error('Непредвиденная ошибка.');
				throw e;
			}
		} while (answer === null);

		return { captchaId: id, text: answer };
	}

	/**
	 * Отправляет жалобу на неправильный ответ
	 * @param {String} captchaId - ID неверно решнной капчи
	 * @return {Promise.<Boolean>}
	 */
	async report(captchaId) {
		return new Promise((resolve, reject) => {
			let params = { 'key': this.apiKey, 'action': 'reportbad', 'id': captchaId };
			let url = 'http://rucaptcha.com/res.php?' + querystring.stringify(params);

			request(url, (err, res, body) => {
				if (err) return reject(err);
				if (res.statusCode > 400) return reject(new Error(res.statusMessage, res.statusCode));
				if (this._hasResponseError(body)) return reject(this._hasResponseError(body));
				return resolve(true);
			});
		});
	}

	/**
	 * Возвращает баланс на аккаунте
	 * @return {Promise.<Number>}
	 */
	get balance() {
		return new Promise((resolve, reject) => {
			let params = { 'key': this.apiKey, 'action': 'getbalance' };
			let url = 'http://rucaptcha.com/res.php?' + querystring.stringify(params);
			request({url: url, encoding: null}, (err, res, body) => {
				if (err) reject(err);
				if (this._hasResponseError(body)) throw this._hasResponseError(body);
				return resolve(Number.parseFloat(body));
			})
		});
	}

	/**
	 * Изображение, которое нужно разгадать
	 * @param {Image} image
	 * @throws {TypeError}
	 */
	set image(image) {
		if (!image instanceof Image) throw TypeError('Первый аргумент должен быть экземпляром Image.');
		this._image = image;
	}

	/** @return {Image} */
	get image() {
		return this._image;
	}

	/**
	 * Отправляет изображение с капчей на сервер рукапчи
	 * @returns {Promise<String>}
	 * @private
	 */
	_sendCaptcha(options = {}) {
		if (!this.image instanceof Image) throw Error('Не указано изображение, которое нужно отправить.');
		let form = {
			key: this.apiKey,
			method: 'base64',
			body: this.image.toBase64(),
			soft_id: '1876'
		};
		this._initOptions.call(form, options);
		if ('headerAcao' in options) this.headerAcao = options.headerAcao;

		return new Promise((resolve, reject) => {
			request.post({ url: 'http://rucaptcha.com/in.php', form }, (err, res, body) => {
				if (err) return reject(err);
				if (res.statusCode > 400) return reject(new Error(res.statusMessage, res.statusCode));
				if (this._hasResponseError(body)) return reject(this._hasResponseError(body));
				let [status, id] = body.split('|');
				if (status !== 'OK') return reject(new Error('Непредвиденная ошибка'));
				return resolve(id);
			})
		});
	}

	/**
	 * Возвращает ответ или null, если капча ещё не решена
	 * @param {String} captchaID
	 * @return {Promise<String>|Promise<null>}
	 * @private
	 */
	_getAnswer(captchaID) {
		return new Promise((resolve, reject) => {
			let params = {
				key: this.apiKey,
				action: 'get',
				id: captchaID
			};
			if (this.headerAcao === 1) params.headerAcao = 1;
			let url = 'http://rucaptcha.com/res.php?' + querystring.stringify(params);

			request(url, (err, res, body) => {
				if (err) return reject(err);
				if (res.statusCode > 400) return reject(new Error(res.statusMessage, res.statusCode));
				if (this._hasResponseError(body)) return reject(this._hasResponseError(body));
				if (body === 'CAPCHA_NOT_READY') return resolve(null);
				let [status, text] = body.split('|');
				if (status !== 'OK') return reject(new Error('Непредвиденная ошибка'));
				return resolve(text);
			});
		});
	}

	/**
	 * Проверяет, есть ли в ответе сообщение об ошибке
	 * @param {String} response
	 * @return {RuCaptchaError|null}
	 * @private
	 */
	_hasResponseError(response) {
		return RuCaptchaError.isRuCaptchaError(response);
	}

	/**
	 * Инициализирует опции
	 * @param {Object} options
	 * @private
	 */
	_initOptions(options) {
		let allowOptions = [
			'phrase', 'regsense', 'numeric', 'calc', 'minLen', 'maxLen', 'language',
			'textInstructions', 'imgInstructions', 'headerAcao', 'pingback'
		];
		for (let option of allowOptions)
			if (option in options)
				this[option] = options[option];
	}
}

module.exports = RuCaptchaClient;