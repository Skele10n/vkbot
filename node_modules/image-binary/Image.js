'use strict';

const path = require('path');
const fs = require('fs');
const request = require('request');

class Image {
	/**
	 * @param {String} mimeType
	 * @param {Buffer} data
	 */
	constructor(mimeType, data) {
		this.mimeType = mimeType;
		this.data = data;
	}

	/**
	 * Асинхронно сохраняет изображение и возвращает путь к нему
	 * @return {Promise<String>}
	 */
	save() {
		return new Promise((resolve, reject) => {
			let name = Math.random().toString(36).substring(7).slice(0, 6);
			let pathToFile = path.join(__dirname, name + this.extension);
			fs.appendFile(pathToFile, this.data, (err) => {
				if (err) return reject(err);
				resolve(pathToFile);
			});
		});
	}

	/**
	 * Возвращает base64 представление изображения
	 * @return {String}
	 */
	toBase64() {
		return 'data:' + this.mimeType + ';base64,' + this.data.toString('base64');
	}

	/**
	 * Возвращает расширение файла
	 * @return {String}
	 */
	get extension() {
		switch (this.mimeType) {
			case 'image/jpeg': return '.jpg';
			case 'image/png': return '.png';
			case 'image/gif': return '.gif';
		}
		return '';
	}

	/**
	 * Создаёт изображение из uri. Допустимые форматы: base64, путть в
	 * файловой системе или url.
	 * @param {String} uri
	 * @throws {TypeError}
	 */
	static async create(uri) {
		if (path.isAbsolute(uri)) return await Image.open(uri);
		if (isUrl()) return await Image.download(uri);
		if (isBase64()) return Image.createFromBase64(uri);
		throw new TypeError('Некорректный uri');

		function isUrl() {
			return /^(https?|ftp):\/\//.test(uri);
		}

		function isBase64() {
			return /^data:(image\/jpe?g|image\/png|image\/gif);base64,/i.test(uri);
		}
	}

	/**
	 * Создаёт изображение из base64 формата
	 * @param {String} base64
	 * @return {Image}
	 */
	static createFromBase64(base64) {
		let mime = base64.match(/^data:(image\/jpe?g|image\/png|image\/gif)/i)[1];
		let start = String('data:' + mime + ';base64,').length;
		let data = Buffer.from(base64.slice(start), 'base64');
		return new Image(mime, data);
	}

	/**
	 * Скачивает изображение по ссылке
	 * @param {String} url - ссылка на изображение
	 * @return {Promise<Image>}
	 * @throws {TypeError}
	 */
	static download(url) {
		return new Promise((resolve, reject) => {
			request({ url: url, encoding: null }, function (err, res, body) {
				if (err) reject(err);
				if (!'content-type' in res.headers) throw TypeError(url + ' не является изображением.');
				let contentType = res.headers['content-type'];
				if (contentType !== 'image/jpeg' && contentType !== 'image/png' && contentType !== 'image/gif')
					reject('Недопустимый формат изображения.');
				//noinspection JSCheckFunctionSignatures
				resolve(new Image(contentType, Buffer.from(body)));
			});
		});
	}

	/**
	 * Асинхронно открывает изображение
	 * @param {String} pathToFile
	 * @return {Promise<Image>}
	 * @throws {TypeError}
	 */
	static open(pathToFile) {
		let mime = Image._getMimeByExtension(path.extname(pathToFile));
		if (mime === '') throw TypeError('Недопустимый формат изображения.');

		return new Promise((resolve, reject) => {
			fs.readFile(pathToFile, (err, data) => {
				if (err) return reject(err);
				resolve(new Image(mime, data));
			});
		});
	}

	/**
	 * Возвращает mime тип изображения исходя из его расширения.
	 * Вернёт пустую строку, если попадётся неизвестный формат.
	 * @param {String} ext - расширение
	 * @return {String}
	 * @private
	 */
	static _getMimeByExtension(ext) {
		switch (ext) {
			case '.jpg':
			case '.jpeg': return 'image/jpeg';
			case '.png': return 'image/png';
			case '.gif': return 'image/gif';
			default: return '';
		}
	}
}

module.exports = Image;